[{"title":"前端知识大杂烩","date":"2022-10-08T02:03:02.307Z","url":"/2022/10/08/hello-world/","tags":[["hello","/tags/hello/"]],"categories":[["undefined",""]],"content":"依据个人兴趣工作记录知识点(希望能长期更新吧) "},{"title":"简单的博客搭建部署","date":"2022-09-18T05:05:46.000Z","url":"/2022/09/18/%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/","tags":[["hexo","/tags/hexo/"]],"categories":[["undefined",""]],"content":"主要介绍下基于hexo的博客搭建（本博客也是使用这工具搭建）相信各位对于前端的基本个工具npm和node已经非常熟练，这里就不多废话了 相关配置和发布github配置项挺多这里主要参考官网详细介绍下发布github，虽然官方也有，但容易踩坑。。。一键部署 首先要在github搭建属于自己的仓库，这里偷个懒使用vecode的小伙伴在项目搭建完成后可以直接在vscdo的左上角的源代码管理发布到github注意仓库的命名最是(github用户名 + .github.io)，这样就可用户名.io访问 在 _config.yml中修改参数 注意 branch分支必须和写博客的分支分开以免冲突 在package.json中添加命令 且执行 稍等片刻既可访问。如果地址不对可以打开github对应的仓库settings的pages查看地址"},{"title":"JS实现发布订阅模式","date":"2022-09-17T13:08:46.000Z","url":"/2022/09/17/JS%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","tags":[["JS","/tags/JS/"]],"categories":[["设计模式","/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"发布订阅模式的基本概念发布订阅模式（Publish&#x2F;Subscribe）它定义了一种一对多的关系，让多个订阅者同时监听某一个发布者，这个发布者发生变化时就会通知所有的订阅者对象，使得它们能够触发 对应的回调。 发布订阅模式中有三个角色，发布者 Publisher ，事件调度中心 Event Channel ，订阅者 Subscribe。 发布订阅模式是一种我们生活中非常常见的模式列如微信订阅公众号，公众号就是发布者，而订阅者就是微信的部分用户 发布订阅模式在前端技术架构上也是一个非常常见的模式，在 vue 的源码中，为了让数据劫持和视图驱动解耦就是通过架设一层消息管理层实现的，而这一层消息管理层实现的原理就是发布订阅模式。再比如 Redux、Vuex 这些当下比较流行的库基本上都离不开发布订阅模式。 话不多说直接上代码核心代码 由此可以发布订阅模式其实就是触发相关的回调其实是一个很容易理解的设计模式我门在vue，react中使用这个方式来实现组件emit事件也是可以行，不过为了维护等方面的问题，不建议在实际项目中使用 父组件 子组件 其实看到这儿就很明显，流程其实和的emit事件方式几乎一模一样，父组件注册相关回调，子组件触发事件回调，ok今天就到这儿结束"},{"title":"JS实现发布订阅模式","date":"2022-09-17T13:08:46.000Z","url":"/2022/09/17/promise%E5%B8%B8%E7%94%A8api%E7%9A%84%E5%AE%9E%E7%8E%B0/","tags":[["promise","/tags/promise/"]],"categories":[["ES6","/categories/ES6/"]],"content":"手写 Promise 的常用 api实现一个 api 最重要的是要详细了解这个 api 的功能,所以在实现之前我们需要简单的回顾一下 Promise.resolve 返回值始终是一个 Promise 对象 如果这个值是 thenable（即带有 “then” 方法），返回的 promise 会“跟随”这个 thenable 的对象 其实根据 resolve 的结果我们很明显观察出 Promise.resolve 的入参如果不是 promise 直接包了一层，如果是直接返回该 promise,了解了 Promise.resolve 的作用那么实现也是很简单的了 测试 看到这里可能还有个疑惑就是 thenable 的处理。(这个应该都是 promise 处理的。因为 myResolve 的实现也基于 promise。。) Promise.reject这个相对于 resolve 更简单，返回一个状态 rejected 的 Preomise 即可 Promise.all 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入,并且只返回一个 Promise 实例 输入的所有 promise 的 resolve 回调的结果是一个数组 只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。 "}]